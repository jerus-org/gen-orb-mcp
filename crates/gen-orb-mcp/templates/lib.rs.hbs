//! {{orb_name}} MCP Server
//!
{{#if description_doc}}
{{{description_doc}}}
//!
{{/if}}
//! This library provides an MCP server that exposes the {{orb_name}} CircleCI orb
//! as resources for AI coding assistants.
//!
//! ## Resources
//!
//! The server exposes the following resource URIs:
//!
{{#each commands}}
//! - `{{uri}}` - Command: {{name}}
{{/each}}
{{#each jobs}}
//! - `{{uri}}` - Job: {{name}}
{{/each}}
{{#each executors}}
//! - `{{uri}}` - Executor: {{name}}
{{/each}}
//! - `orb://overview` - Full orb summary
//!
//! Generated by gen-orb-mcp.

use rmcp::{
    ErrorData as McpError,
    ServerHandler,
    model::*,
    service::RequestContext,
    RoleServer,
};
use serde_json::json;

/// The MCP server for the {{orb_name}} orb.
#[derive(Clone)]
pub struct OrbServer;

impl OrbServer {
    /// Create a new instance of the orb server.
    pub fn new() -> Self {
        Self
    }
}

impl Default for OrbServer {
    fn default() -> Self {
        Self::new()
    }
}

impl ServerHandler for OrbServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::LATEST,
            capabilities: ServerCapabilities::builder().enable_resources().build(),
            server_info: Implementation {
                name: "{{orb_name}}-mcp".into(),
                version: "{{version}}".into(),
            },
            instructions: Some("MCP server for the {{orb_name}} CircleCI orb".into()),
        }
    }

    fn list_resources(
        &self,
        _request: Option<PaginatedRequestParams>,
        _ctx: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<ListResourcesResult, McpError>> + Send + '_ {
        async move {
            Ok(ListResourcesResult {
                resources: vec![
                    RawResource::new("orb://overview", "{{orb_name}} Overview")
                        .with_description("Complete overview of the {{orb_name}} CircleCI orb")
                        .no_annotation(),
{{#each commands}}
                    RawResource::new("{{uri}}", "{{name}}")
                        .with_description("Command: {{name}}{{#if description_escaped}} - {{description_escaped}}{{/if}}")
                        .no_annotation(),
{{/each}}
{{#each jobs}}
                    RawResource::new("{{uri}}", "{{name}}")
                        .with_description("Job: {{name}}{{#if description_escaped}} - {{description_escaped}}{{/if}}")
                        .no_annotation(),
{{/each}}
{{#each executors}}
                    RawResource::new("{{uri}}", "{{name}}")
                        .with_description("Executor: {{name}}{{#if description_escaped}} - {{description_escaped}}{{/if}}")
                        .no_annotation(),
{{/each}}
                ],
                next_cursor: None,
                meta: None,
            })
        }
    }

    fn read_resource(
        &self,
        request: ReadResourceRequestParams,
        _ctx: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = Result<ReadResourceResult, McpError>> + Send + '_ {
        async move {
            let uri = request.uri.as_str();
            let content = match uri {
                "orb://overview" => OVERVIEW_CONTENT.to_string(),
{{#each commands}}
                "{{uri}}" => r##"{{json_content}}"##.to_string(),
{{/each}}
{{#each jobs}}
                "{{uri}}" => r##"{{json_content}}"##.to_string(),
{{/each}}
{{#each executors}}
                "{{uri}}" => r##"{{json_content}}"##.to_string(),
{{/each}}
                _ => {
                    return Err(McpError::resource_not_found(
                        "Resource not found",
                        Some(json!({"uri": uri})),
                    ));
                }
            };

            Ok(ReadResourceResult {
                contents: vec![ResourceContents::text(content, request.uri)],
                meta: None,
            })
        }
    }
}

/// Overview content for the orb.
const OVERVIEW_CONTENT: &str = r##"# {{orb_name}} CircleCI Orb

{{#if description}}
{{description}}

{{/if}}
## Commands ({{length commands}})

{{#each commands}}
### {{name}}
{{#if description}}
{{description}}
{{/if}}

URI: `{{uri}}`

{{#if parameters}}
**Parameters:**
{{#each parameters}}
- `{{name}}` ({{param_type}}{{#unless required}}, optional{{/unless}}){{#if description}}: {{description}}{{/if}}
{{/each}}
{{/if}}

{{/each}}
## Jobs ({{length jobs}})

{{#each jobs}}
### {{name}}
{{#if description}}
{{description}}
{{/if}}

URI: `{{uri}}`

{{#if executor}}
**Executor:** {{executor}}
{{/if}}

{{#if parameters}}
**Parameters:**
{{#each parameters}}
- `{{name}}` ({{param_type}}{{#unless required}}, optional{{/unless}}){{#if description}}: {{description}}{{/if}}
{{/each}}
{{/if}}

{{/each}}
## Executors ({{length executors}})

{{#each executors}}
### {{name}}
{{#if description}}
{{description}}
{{/if}}

URI: `{{uri}}`

{{#if config.docker_images}}
**Docker Images:**
{{#each config.docker_images}}
- {{this}}
{{/each}}
{{/if}}

{{#if config.resource_class}}
**Resource Class:** {{config.resource_class}}
{{/if}}

{{#if parameters}}
**Parameters:**
{{#each parameters}}
- `{{name}}` ({{param_type}}{{#unless required}}, optional{{/unless}}){{#if description}}: {{description}}{{/if}}
{{/each}}
{{/if}}

{{/each}}
"##;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_server() {
        let server = OrbServer::new();
        // Basic smoke test - server should be created without panicking
        let _ = server;
    }

    #[test]
    fn test_server_info() {
        let server = OrbServer::new();
        let info = server.get_info();
        assert_eq!(info.server_info.name, "{{orb_name}}-mcp");
        assert_eq!(info.server_info.version, "{{version}}");
    }
}
